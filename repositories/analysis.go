//go:generate go run go.uber.org/mock/mockgen -source=analysis.go -destination=../mocks/mock_analysis_repository.go -package=mocks
package repositories

import (
	pb "chat-lab/proto/storage"
	"fmt"
	"github.com/blugelabs/bluge"
	"github.com/dgraph-io/badger/v4"
	"github.com/google/uuid"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/timestamppb"
	"log/slog"
	"time"
)

type IAnalysisRepository interface {
	Store(analysis Analysis) error
	StoreBatch(analyses []Analysis) error
	GetAnalyses(roomID string, cursor *string) ([]Analysis, *string, error)
	GetByMessageId(roomID string, messageId uuid.UUID) (Analysis, error)
	Search(query string, roomID string) ([]Analysis, error)
}

type AnalysisRepository struct {
	db     *badger.DB
	writer *bluge.Writer
	log    *slog.Logger
	limit  *int
}

func NewAnalysisRepository(db *badger.DB, writer *bluge.Writer, log *slog.Logger, limit *int) *AnalysisRepository {
	return &AnalysisRepository{db: db, writer: writer, log: log, limit: limit}
}

// Analysis represents the enriched metadata generated by the AI pipeline for a message.
// It acts as a bridge between specialized AI models (toxicity, sentiment, business)
// and the storage layer, supporting multi-modal payloads.
//
// Key design points:
//   - Id: Unique identifier for the analysis record itself.
//   - MessageId: Links the analysis to the original chat message.
//   - RoomId: Used as the primary partition key in BadgerDB for efficient prefix scans.
//   - At: Timestamp used to maintain reverse chronological order in the "War Room" UI.
//   - Scores: Map of technical metrics (e.g., toxicity: 0.98) aligned with Protobuf's float64/double.
//   - Payload: A flexible container for specialized data types (TextContent, AudioDetails, or FileDetails).
//   - Version: Tracks which AI model version produced this data for schema evolution management.
type Analysis struct {
	Id        uuid.UUID
	MessageId uuid.UUID
	RoomId    string
	At        time.Time
	Summary   string
	Tags      []string
	Scores    map[string]float64
	Payload   any
	Version   uuid.UUID
}

type TextContent struct {
	Content string
}

type AudioDetails struct {
	Transcription string
	Duration      uint32
}

type FileDetails struct {
	Filename string
	MimeType string
	Size     uint64
}

// Store persists the analysis in BadgerDB and indexes its content in Bluge.
// This dual-write approach ensures that the data is both durable (Source of Truth)
// and searchable in real-time. The method dynamically selects the most relevant
// content to index based on the payload type (Text, Audio, or File).
func (a AnalysisRepository) Store(analysis Analysis) error {
	key := buildKey(analysis.RoomId, analysis.At, analysis.MessageId)

	bytes, err := proto.Marshal(fromAnalysis(analysis))
	if err != nil {
		return err
	}

	err = a.db.Update(func(txn *badger.Txn) error {
		return txn.Set(key, bytes)
	})
	if err != nil {
		return fmt.Errorf("badger storage failed: %w", err)
	}
	contentToIndex := analysis.Summary
	category := "general"

	// Business logic to select what to index based on the payload
	switch p := analysis.Payload.(type) {
	case TextContent:
		contentToIndex = p.Content
		category = "text"
	case AudioDetails:
		contentToIndex = p.Transcription
		category = "audio"
	case FileDetails:
		contentToIndex = p.Filename
		category = "file"
	}

	return a.IndexAnalysis(
		analysis.MessageId.String(),
		contentToIndex,
		analysis.Scores,
		category,
	)
}

func (a AnalysisRepository) StoreBatch(analyses []Analysis) error {
	wb := a.db.NewWriteBatch()
	defer wb.Cancel()

	for _, anal := range analyses {
		analysisPb := fromAnalysis(anal)
		bytes, err := proto.Marshal(analysisPb)
		if err != nil {
			return err
		}

		key := buildKey(anal.RoomId, anal.At, anal.MessageId)
		if err := wb.Set(key, bytes); err != nil {
			return err
		}
	}
	return wb.Flush()
}

func (a AnalysisRepository) GetAnalyses(roomID string, cursor *string) ([]Analysis, *string, error) {
	var analyses []Analysis
	var lastKey string

	err := a.db.View(func(txn *badger.Txn) error {
		prefixStr := fmt.Sprintf("analysis:%s:", roomID)
		prefix := []byte(prefixStr)
		prefixLen := len(prefixStr)

		opts := badger.DefaultIteratorOptions
		opts.Reverse = true
		it := txn.NewIterator(opts)
		defer it.Close()

		var seekKey []byte
		if cursor == nil {
			seekKey = append(prefix, []byte("9999999999999999999")...)
		} else {
			seekKey = append(prefix, []byte(*cursor)...)
		}

		it.Seek(seekKey)

		if cursor != nil && it.ValidForPrefix(prefix) {
			it.Next()
		}

		for ; it.ValidForPrefix(prefix); it.Next() {
			if a.limit != nil && len(analyses) >= *a.limit {
				break
			}

			item := it.Item()
			lastKey = string(item.Key()[prefixLen:])

			err := item.Value(func(v []byte) error {
				var pbAnal pb.Analysis
				if err := proto.Unmarshal(v, &pbAnal); err != nil {
					return err
				}

				anal, errMapping := toAnalysis(&pbAnal)
				if errMapping != nil {
					return errMapping
				}
				analyses = append(analyses, anal)
				return nil
			})
			if err != nil {
				return err
			}
		}
		return nil
	})

	if err != nil || len(analyses) == 0 {
		return analyses, nil, err
	}
	return analyses, &lastKey, nil
}

func (a AnalysisRepository) GetByMessageId(roomID string, messageId uuid.UUID) (Analysis, error) {
	var result Analysis
	prefix := []byte(fmt.Sprintf("analysis:%s:", roomID))
	msgIDStr := messageId.String()

	err := a.db.View(func(txn *badger.Txn) error {
		it := txn.NewIterator(badger.DefaultIteratorOptions)
		defer it.Close()

		for it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() {
			item := it.Item()
			key := string(item.Key())

			// On cherche le messageId à la fin de la clé
			if len(key) >= len(msgIDStr) && key[len(key)-len(msgIDStr):] == msgIDStr {
				return item.Value(func(v []byte) error {
					var pbAnal pb.Analysis
					if err := proto.Unmarshal(v, &pbAnal); err != nil {
						return err
					}
					res, errMapping := toAnalysis(&pbAnal)
					result = res
					return errMapping
				})
			}
		}
		return fmt.Errorf("analysis not found for message: %s", messageId)
	})

	return result, err
}

func (a AnalysisRepository) Search(query string, roomID string) ([]Analysis, error) {
	return nil, nil
}

func fromAnalysis(analysis Analysis) *pb.Analysis {
	res := &pb.Analysis{
		Id:        analysis.Id.String(),
		MessageId: analysis.MessageId.String(),
		RoomId:    analysis.RoomId,
		At:        timestamppb.New(analysis.At),
		Summary:   analysis.Summary,
		Tags:      analysis.Tags,
		Scores:    analysis.Scores, // Direct mapping possible avec float64
	}

	switch p := analysis.Payload.(type) {
	case TextContent:
		res.Payload = &pb.Analysis_TextContent{
			TextContent: &pb.TextContent{Content: p.Content},
		}
	case AudioDetails:
		res.Payload = &pb.Analysis_Audio{
			Audio: &pb.AudioDetails{
				Transcription: p.Transcription,
				DurationSec:   p.Duration,
			},
		}
	case FileDetails:
		res.Payload = &pb.Analysis_File{
			File: &pb.FileDetails{
				Filename: p.Filename,
				MimeType: p.MimeType,
				Size:     p.Size,
			},
		}
	}
	return res
}

func (a AnalysisRepository) IndexAnalysis(id, content string,
	metadata map[string]float64, category string) error {
	// 1. Create a document with the SAME ID as Badger
	doc := bluge.NewDocument(id)

	// 2. Full-text field (stored and indexed)
	doc.AddField(bluge.NewTextField("content", content))

	// 3. Category field (to filter by "Invoice", "Spec", etc.)
	doc.AddField(bluge.NewKeywordField("type", category))

	// 4. Dynamic numeric fields (scores, amounts, etc.)
	for key, value := range metadata {
		doc.AddField(bluge.NewNumericField(key, value))
	}

	// 5. Atomic update in the index
	return a.writer.Update(doc.ID(), doc)
}

func Search(query string, roomID string) ([]Analysis, error) {
	return nil, nil
}

// buildKey: analysis:{room_id}:{timestamp_padded}:{message_id}
func buildKey(roomID string, at time.Time, messageID uuid.UUID) []byte {
	return []byte(fmt.Sprintf("analysis:%s:%019d:%s",
		roomID,
		at.UnixNano(),
		messageID.String(),
	))
}

func toAnalysis(analysisPb *pb.Analysis) (Analysis, error) {
	id, _ := uuid.Parse(analysisPb.Id)
	messageID, _ := uuid.Parse(analysisPb.MessageId)

	res := Analysis{
		Id:        id,
		MessageId: messageID,
		RoomId:    analysisPb.RoomId,
		At:        analysisPb.At.AsTime(),
		Summary:   analysisPb.Summary,
		Tags:      analysisPb.Tags,
		Scores:    analysisPb.Scores,
	}

	if analysisPb.Payload != nil {
		switch p := analysisPb.Payload.(type) {
		case *pb.Analysis_TextContent:
			res.Payload = TextContent{Content: p.TextContent.Content}
		case *pb.Analysis_Audio:
			res.Payload = AudioDetails{
				Transcription: p.Audio.Transcription,
				Duration:      p.Audio.DurationSec,
			}
		case *pb.Analysis_File:
			res.Payload = FileDetails{
				Filename: p.File.Filename,
				MimeType: p.File.MimeType,
				Size:     p.File.Size,
			}
		}
	}
	return res, nil
}
